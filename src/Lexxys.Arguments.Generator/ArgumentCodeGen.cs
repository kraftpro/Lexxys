using System;
using System.Collections;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;
using System.ComponentModel;
using Microsoft.CodeAnalysis.Operations;
using System.Diagnostics;

namespace Lexxys.Arguments.Generator;

[Generator]
public class ArgumentCodeGen: ISourceGenerator
{
	public ArgumentCodeGen()
	{
	}

	public void Initialize(GeneratorInitializationContext context)
	{
		context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
	}

	private static readonly DiagnosticDescriptor CollectedArgumentWarning = new DiagnosticDescriptor(
		id: "ARG001",
		title: "Couldn't parse XML file",
		messageFormat: "Collected attribute: '{0}'",
		category: "Design",
		DiagnosticSeverity.Warning,
		isEnabledByDefault: true);

	public void Execute(GeneratorExecutionContext context)
	{
		var collector = (SyntaxReceiver)context.SyntaxReceiver!;
		var attributes = collector.Attributes;
		if (attributes.Count <= 0) return;

		List<ArgumentClassModel> models = attributes
			.Select(HandleCliArguments)
			.Where(o => o != null)
			.Select(o => o!)
			.ToList();
		models.Sort(ModelsComparer.Instance);

		var text = new StringBuilder();
		text.Append("""
		// <auto-generated/>
		using System;
		using System.Collections.Generic;
		using System.Linq;
		using System.Text;

		//#pragma warning disable
		#nullable enable
		""");

		models.Sort((x, y) => x.FullName.CompareTo(y.FullName));

		string lastName = String.Empty;
		string lastNamespace = String.Empty;
		int indent = 0;
		foreach (var model in models)
		{
			var fullName = model.FullName;
			int i = fullName.IndexOf('+');
			var thisNamespace = fullName.Substring(0, i);
			var thisName = fullName.Substring(i + 1);
			// text.AppendLine().Append("// |").Append(lastName).Append('|').AppendLine(thisName);

			if (lastNamespace != thisNamespace)
			{
				lastNamespace = thisNamespace;
				while (indent > 0)
				{
					--indent;
					text.Append('\t', indent).Append("}").AppendLine();
				}
				text.AppendLine()
					.Append("namespace ").Append(lastNamespace).AppendLine()
					.AppendLine("{");
				indent = 1;
			}
			else
			{
				while (!thisName.StartsWith(lastName + "+"))
				{
					--indent;
					i = lastName.LastIndexOf('+');
					text.Append('\t', indent).Append("}").AppendLine();
					if (i < 0)
					{
						lastName = String.Empty;
						break;
					}
					lastName = lastName.Substring(0, i);
				}
				text.AppendLine();
			}

			var name = lastName.Length == 0 ? thisName: thisName.Substring(lastName.Length + 1);
			lastName = thisName;
			i = name.IndexOf('+');
			while (i > 0)
			{
				text.Append('\t', indent).Append("partial class ").Append(name, 0, i).AppendLine();
				name = name.Substring(i + 1);
				i = name.IndexOf('+');
				++indent;
			}

			GenerateClass(indent, text, model);
			++indent;
		}

		int j = lastName.IndexOf('+');

		while (indent > 0)
		{
			--indent;
			text.Append('\t', indent).Append("}").AppendLine();
		}
		var source = text.ToString();
		context.AddSource("CliGeneratorExtensions_Generated.g.cs", source);
	}

	private static void GenerateClass(int indent, StringBuilder text, ArgumentClassModel model)
	{
		text.Append('\t', indent).AppendLine($"partial class {model.Name}: ICliOption<{model.Name}>");
		text.Append('\t', indent).AppendLine("{");
		++indent;
		text.Append('\t', indent).AppendLine($"public static {model.Name} Parse(IReadOnlyCollection<string> args) => Parse(CreateBuilder().Build(args));");
		text.AppendLine();
		text.Append('\t', indent).AppendLine($"public static {model.Name} Parse(IArgumentCommand c) => new {model.Name}");
		text.Append('\t', indent).AppendLine("{");
		foreach (var item in model.Properties)
		{
			if (item.IsCommand) continue;
			text.Append('\t', indent + 1)
				.Append(item.Name)
				.Append(" = c.Parameters.Value<").Append(item.Type).Append(">(\"").AppendArgName(item.Name)
				.AppendLine(")\", default),");
		}
		foreach (var item in model.Properties)
		{
			if (!item.IsCommand) continue;
			text.Append('\t', indent + 1)
				.Append(item.Name)
				.Append(" = c.Command?.Name == \"").AppendArgName(item.Name).Append("\" ? ")
				.Append(item.Type?.TrimEnd('?')).AppendLine(".Parse(c.Command): null,");
		}
		text.Append('\t', indent).AppendLine("};");

		List<string[]> aliases = model.Properties
			.Select(o => o.ParamAttribute?.Alias ?? o.CommandAttribute?.Alias ?? Array.Empty<string>())
			.ToList();
		if (aliases.Count > 0)
		{
			for (var i = 0; i < aliases.Count; ++i)
			{
				Array.Sort(aliases[i]);
			}
			aliases.Distinct(AliasEqualityComparer.Instance);
		}

		text.AppendLine();
		text.Append('\t', indent).Append("public static ArgumentsBuilder CreateBuilder(ArgumentsBuilder? builder = null) => (builder ?? new ArgumentsBuilder())");
		foreach (var item in model.Properties)
		{
			if (item.IsCommand) continue;
			var attrib = item.ParamAttribute;
			text.AppendLine()
				.Append('\t', indent + 1).Append(".Parameter(\"").AppendArgName(item.Name).Append('"');
			if (attrib?.Alias is { Length: > 0 })
				text.Append(", __aliases[")
					.Append(aliases.FindIndex(o => AliasEqualityComparer.Instance.Equals(o, attrib.Alias)))
					.Append("]");
			if (attrib?.ValueName is { Length: > 0 })
				text.Append(", valueName: ").Append(attrib.ValueName);
			if (attrib?.Description is { Length: > 0 })
				text.Append(", description: ").Append(attrib.Description);
			text.Append(')');
		}

		foreach (var item in model.Properties)
		{
			if (!item.IsCommand) continue;
			var attrib = item.CommandAttribute;
			text.AppendLine()
				.Append('\t', indent + 1)
				.Append(".Command<").Append(item.Type?.TrimEnd('?')).Append($">(\"")
				.AppendArgName(item.Name).Append('"');
			if (attrib?.Alias is { Length: > 0 })
				text.Append(", __aliases[")
					.Append(aliases.FindIndex(o => AliasEqualityComparer.Instance.Equals(o, attrib.Alias)))
					.Append("]");
			if (attrib?.Description is { Length: > 0 })
				text.Append(", description: ").Append(attrib.Description);
			text.Append(')');
		}
		text.AppendLine(";");

		if (aliases.Count > 1 || aliases[0].Length > 0)
			text.AppendLine()
				.Append('\t', indent).Append("private static readonly string[][] __aliases = [[")
				.Append(String.Join("], [", aliases.Select(o => String.Join(", ", o))))
				.AppendLine("]];");
	}

	class ModelsComparer: IComparer<(ArgumentClassModel Model, List<string>)>, IComparer<ArgumentClassModel>
	{
		public static readonly ModelsComparer Instance = new ModelsComparer();

		public int Compare((ArgumentClassModel Model, List<string>) x, (ArgumentClassModel Model, List<string>) y)
			=> String.Compare(x.Model.FullName, y.Model.FullName, StringComparison.Ordinal);

		public int Compare(ArgumentClassModel x, ArgumentClassModel y)
			=> String.Compare(x?.FullName, y?.FullName, StringComparison.Ordinal);
	}

	class AliasEqualityComparer: EqualityComparer<string[]?>
	{
		public static readonly EqualityComparer<string[]?> Instance = new AliasEqualityComparer();

		public override bool Equals(string[]? x, string[]? y)
		{
			if (x is not { Length: >0 }) return y is not { Length: >0 };
			if (y is not { Length: > 0 }) return false;
			if (x.Length != y.Length) return false;
			for (var i = 0; i < x.Length; ++i)
			{
				if (x[i] != y[i]) return false;
			}
			return true;
		}

		public override int GetHashCode(string[]? obj)
		{
			if (obj is null) return 0;
			int hash = obj.Length;
			foreach (string s in obj)
			{
				hash = unchecked(hash * 31 + s.GetHashCode());
			}
			return hash;
		}
	}

	private ArgumentClassModel? HandleCliArguments(AttributeSyntax attrib)
	{
		var argAttribute = HandleCliArgumentsAttribute(attrib);
		if (attrib.Parent?.Parent is not ClassDeclarationSyntax classDeclaration)
			return null;
		var className = classDeclaration.Identifier.ValueText;
		var classNameSpace = GetNameSpace(classDeclaration);
		var classRecord = new ArgumentClassModel(className, classNameSpace, argAttribute);

		foreach (var member in classDeclaration.Members)
		{
			CliParamModel? paramAttribute = GetParamAttribute(member);
			CliCommandModel? commandAttribute = GetCommandAttribute(member); // memberAttributes.FirstOrDefault(o => o.Attributes.Any(a => a.Name.ToString() is "CliCommandAttribute" or "CliCommand"));

			if (member is PropertyDeclarationSyntax property)
			{
				if (!CheckModifiers(property.Modifiers))
					continue;
				var propertyType = property.Type;
				var propertyName = property.Identifier.ValueText;
				ArgumentPropertyModel arg = new ArgumentPropertyModel(name: propertyName, propertyType.ToString(), paramAttribute, commandAttribute);
				classRecord.Properties.Add(arg);
			}
			else if (member is FieldDeclarationSyntax field)
			{
				if (!CheckModifiers(field.Modifiers))
					continue;
				var propertyType = field.Declaration.Type;
				var propertyName = field.Declaration.ToString();
				ArgumentPropertyModel arg = new ArgumentPropertyModel(name: propertyName, propertyType.ToString(), paramAttribute, commandAttribute);
				classRecord.Properties.Add(arg);
			}

			static bool CheckModifiers(SyntaxTokenList modifiers)
			{
				bool valid = false;
				foreach (var item in modifiers)
				{
					if (item.ValueText is "static" or "readonly" or "abstract")
						return false;
					if (item.ValueText is "public" or "protected" or "internal")
						valid = true;
				}
				return valid;
			}
			// var propName = property.Identifier.ValueText;
			// var propType = prop.Type.ToString();
			// var propAccessors = prop.AccessorList!;
			// var propGet = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.GetAccessorDeclaration));
			// var propSet = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.SetAccessorDeclaration));
			// var propInit = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.InitAccessorDeclaration));
			// var propModifiers = prop.Modifiers.Select(p => p.ValueText).ToList();
		}

		return classRecord;




		// var attribList = attrib.Parent as AttributeListSyntax;
		// var cls = attrib.Parent!.Parent as ClassDeclarationSyntax;
		// var attribArgs = attrib.ArgumentList!.Arguments;
		// foreach (var attribArg in attribArgs)
		// {
		// 	var expression = attribArg.Expression;
		// 	var nameEqual = attribArg.NameEquals;
		// 	var nameColon = attribArg.NameColon;
		// 	var nameId = nameColon != null ? nameColon.Name : nameEqual != null ? nameEqual.Name : null;
		// 	var name = nameId?.Identifier.ValueText;
		// 	var exp = nameColon != null ? nameColon.Expression : null; // nameEqual != null ? nameEqual.E
		// 	Debug.Print(name);
		// }
		// var cls = attribList!.Parent as ClassDeclarationSyntax;
		// var clsName = cls!.Identifier.ValueText;
		// foreach (var member in cls.Members)
		// {
		// 	var memStr = member.ToString();
		// 	var memberAttr = member.AttributeLists;
		// 	var memberAttrStr = memberAttr.ToString();
		// 	if (member is PropertyDeclarationSyntax prop)
		// 	{
		// 		var propName = prop.Identifier.ValueText;
		// 		var propType = prop.Type.ToString();
		// 		var propAccessors = prop.AccessorList!;
		// 		var propGet = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.GetAccessorDeclaration));
		// 		var propSet = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.SetAccessorDeclaration));
		// 		var propInit = propAccessors.Accessors.FirstOrDefault(o => o.IsKind(SyntaxKind.InitAccessorDeclaration));
		// 		var propModifiers = prop.Modifiers.Select(p => p.ValueText).ToList();
		//
		// 	}
		// 	else if (member is FieldDeclarationSyntax field)
		// 	{
		// 	}
		// }
	}

	private CliCommandModel? GetCommandAttribute(MemberDeclarationSyntax? member)
	{
		if (member == null) return null;
		AttributeSyntax attrib = member.AttributeLists.SelectMany(o => o.Attributes).FirstOrDefault(a => a.Name.ToString() is "CliCommandAttribute" or "CliCommand");
		if (attrib == null) return null;

		string[] alias = GetAliasParameter(attrib);
		IDictionary<string, string> optional = GetFieldsAssignment(attrib);

		var pm = new CliCommandModel(
			alias: alias,
			description: optional.GetValueOrDefault("Description"));
		return pm;
	}

	private string[] GetAliasParameter(AttributeSyntax attrib)
	{
		List<(string? Name, AttributeArgumentSyntax Arg)>? attribPositional = GetPositionalParameters(attrib);
		if (attribPositional == null) return Array.Empty<string>();

		List<string> result = new List<string>();
		foreach (var item in attribPositional)
		{
			ExpressionSyntax exp = item.Arg.Expression;
			if (exp is CollectionExpressionSyntax collection)
				result.AddRange(collection.Elements.Select(o => o.ToString()));
			else if (exp is ImplicitArrayCreationExpressionSyntax { Initializer: not null } implicitArray)
				result.AddRange(implicitArray.Initializer.Expressions.Select(o => o.ToString()));
			else if (exp is ArrayCreationExpressionSyntax { Initializer: not null } array)
				result.AddRange(array.Initializer.Expressions.Select(o => o.ToString()));
			else
				result.Add(exp.ToString());
		}
		return result.ToArray();
	}

	private List<(string? Name, AttributeArgumentSyntax Arg)>? GetPositionalParameters(AttributeSyntax attrib)
	{
		if (attrib.ArgumentList == null) return null;
		SeparatedSyntaxList<AttributeArgumentSyntax> args = attrib.ArgumentList.Arguments;
		if (args.Count == 0) return null;
		List<(string? Name, AttributeArgumentSyntax Arg)> selected = args.Where(o => o.NameEquals == null).Select(o => (o.NameColon?.Name.Identifier.ValueText, o)).ToList();
		return selected.Count == 0 ? null : selected;
	}

	private Dictionary<string, string> GetFieldsAssignment(AttributeSyntax attrib)
	{
		List<(string Name, AttributeArgumentSyntax Arg)>? attribOptional = GetOptionalParameters(attrib);
		return attribOptional?.ToDictionary(
			o => o.Name,
			o => o.Arg.Expression.ToString()
			) ?? __localEmpty;
	}
	private static readonly Dictionary<string, string> __localEmpty = new Dictionary<string, string>();

	private CliParamModel? GetParamAttribute(MemberDeclarationSyntax? member)
	{
		if (member == null) return null;
		AttributeSyntax attrib = member.AttributeLists.SelectMany(o => o.Attributes).FirstOrDefault(a => a.Name.ToString() is "CliParamAttribute" or "CliParam");
		if (attrib == null) return null;

		string[] alias = GetAliasParameter(attrib);
		IDictionary<string, string> optional = GetFieldsAssignment(attrib);

		var pm = new CliParamModel(
			alias: alias,
			valueName: optional.GetValueOrDefault("ValueName"),
			description: optional.GetValueOrDefault("Description"),
			positional: optional.GetValueOrDefault("Positional"),
			required: optional.GetValueOrDefault("Required"));
		return pm;
	}

	private List<(string Name, AttributeArgumentSyntax Arg)>? GetOptionalParameters(AttributeSyntax attrib)
	{
		if (attrib.ArgumentList == null) return null;
		SeparatedSyntaxList<AttributeArgumentSyntax> args = attrib.ArgumentList.Arguments;
		if (args.Count == 0) return null;
		List<(string Name, AttributeArgumentSyntax Arg)> selected = args.Where(o => o.NameEquals != null).Select(o => (o.NameEquals!.Name.Identifier.ValueText, o)).ToList();
		return selected.Count == 0 ? null : selected;
	}

	private string GetNameSpace(ClassDeclarationSyntax classDeclaration)
	{
		var parent = classDeclaration.Parent;
		return parent switch
		{
			NamespaceDeclarationSyntax ns => ns.Name.ToString(),
			FileScopedNamespaceDeclarationSyntax fns => fns.Name.ToString(),
			ClassDeclarationSyntax cls => GetNameSpace(cls) + "+" + cls.Identifier.ValueText,
			_ => "namespace"
		};
	}

	private CliArgumentsModel HandleCliArgumentsAttribute(AttributeSyntax attrib)
	{
		return new CliArgumentsModel();
	}

	class SyntaxReceiver: ISyntaxReceiver
	{
		public List<AttributeSyntax> Attributes { get; } = new List<AttributeSyntax>();

		public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
		{
			if (syntaxNode is not AttributeSyntax attribute) return;
			var attributeName = attribute.Name.ToString();
			if (attributeName is "CliArgumentsAttribute" or "CliArguments") // or "CliCommandAttribute" or "CliCommand" or "CliParamAttribute" or "CliParam")
			{
				Attributes.Add(attribute);
			}
		}
	}

	class ContextReceiver: ISyntaxContextReceiver
	{
		public List<AttributeSyntax> Attributes { get; } = new List<AttributeSyntax>();

		public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
		{
			if (context.Node is not AttributeSyntax attribute) return;
			var attributeName = attribute.Name.ToString();
			if (attributeName is "CliArgumentsAttribute" or "CliArguments" or "CliCommandAttribute" or "CliCommand" or "CliParamAttribute" or "CliParam")
			{
				Attributes.Add(attribute);
			}
		}
	}

	class EmptyDictionary<TKey, TValue>: IDictionary<TKey, TValue>
	{
		public static readonly IDictionary<TKey, TValue> Instance = new EmptyDictionary<TKey, TValue>();

		public TValue this[TKey key] { get => throw new NotImplementedException(); set => throw new NotImplementedException(); }

		public ICollection<TKey> Keys => Array.Empty<TKey>();

		public ICollection<TValue> Values => Array.Empty<TValue>();

		public int Count => 0;

		public bool IsReadOnly => true;

		public void Add(TKey key, TValue value) => throw new NotImplementedException();

		public void Add(KeyValuePair<TKey, TValue> item) => throw new NotImplementedException();

		public void Clear() { }

		public bool Contains(KeyValuePair<TKey, TValue> item) => false;

		public bool ContainsKey(TKey key) => false;

		public void CopyTo(KeyValuePair<TKey, TValue>[] array, int arrayIndex) { }

		public IEnumerator<KeyValuePair<TKey, TValue>> GetEnumerator() => Enumerable.Empty<KeyValuePair<TKey, TValue>>().GetEnumerator();

		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

		public bool Remove(TKey key) => false;

		public bool Remove(KeyValuePair<TKey, TValue> item) => false;

		public bool TryGetValue(TKey key, out TValue value)
		{
			value = default!;
			return false;
		}
	}
}

internal static class Extensions
{
	public static TValue? GetValueOrDefault<TKey, TValue>(this IDictionary<TKey, TValue> dictionary, TKey key) => dictionary.TryGetValue(key, out var value) ? value: default;
}
